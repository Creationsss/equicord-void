<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Void Repository</title>
		<style>
			body {
				font-family: monospace;
				line-height: 1.8;
				padding: 2rem;
				color: #222;
				background: #fff;
			}
			pre {
				margin: 0.5rem 0 1.5rem;
				white-space: pre-wrap;
			}
			a {
				color: inherit;
			}
			input {
				font-family: monospace;
				font-size: 1rem;
				padding: 0.25rem 0.5rem;
				border: 1px solid #888;
				background: inherit;
				color: inherit;
				outline: none;
				width: 20ch;
			}
			.pkg { display: block; }
			.pkg.hidden { display: none; }
			.ver-ok { color: #2a2; }
			.ver-update { color: #c80; }
			.ver-error { color: #888; }
			@media (prefers-color-scheme: dark) {
				body {
					color: #ddd;
					background: #111;
				}
				input {
					border-color: #555;
				}
				.ver-ok { color: #5b5; }
				.ver-update { color: #eb4; }
			}
		</style>
	</head>
	<body>
		<pre>
Void Repository
===============

A third-party Void Linux binary package repository.

Setup:
  echo "repository=https://void.creations.works" | sudo tee /etc/xbps.d/creations.conf

Install a package:
  sudo xbps-install -S &lt;package&gt;

Update:
  sudo xbps-install -Su

Source: <a href="https://github.com/Creationsss/void-repository">github.com/Creations/void-repository</a>

Packages: <input type="text" id="search" placeholder="search..." autocomplete="off" />
<span id="pkglist"><!-- PACKAGES --></span></pre>
	</body>
	<script>
		document.getElementById("search").addEventListener("input", function () {
			var q = this.value.toLowerCase();
			var pkgs = document.querySelectorAll(".pkg");
			for (var i = 0; i < pkgs.length; i++) {
				pkgs[i].classList.toggle("hidden", q && pkgs[i].textContent.toLowerCase().indexOf(q) === -1);
			}
		});

		(function () {
			var CACHE_KEY = "void-repo-versions";
			var CACHE_TTL = 3600000;
			var cache = {};

			try {
				var stored = JSON.parse(localStorage.getItem(CACHE_KEY));
				if (stored && Date.now() - stored.ts < CACHE_TTL) {
					cache = stored.data;
				}
			} catch (e) {}

			var pkgs = document.querySelectorAll(".pkg[data-repo]");
			var pending = 0;

			for (var i = 0; i < pkgs.length; i++) {
				checkVersion(pkgs[i]);
			}

			function saveCache() {
				try {
					localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data: cache }));
				} catch (e) {}
			}

			function checkVersion(el) {
				var repo = el.getAttribute("data-repo");
				var current = el.getAttribute("data-version");
				var prefix = el.getAttribute("data-tag-prefix") || "";
				var api = el.getAttribute("data-api") || "github";
				var apiUrl = el.getAttribute("data-api-url") || "";

				if (!repo) return;

				if (cache[repo]) {
					showResult(el, current, cache[repo]);
					return;
				}

				var url;
				if (api === "gitlab") {
					url = apiUrl + "/api/v4/projects/" + encodeURIComponent(repo) + "/repository/tags";
				} else if (api === "codeberg") {
					url = "https://codeberg.org/api/v1/repos/" + repo + "/releases/latest";
				} else if (prefix === "desktop-v") {
					url = "https://api.github.com/repos/" + repo + "/releases";
				} else {
					url = "https://api.github.com/repos/" + repo + "/releases/latest";
				}

				pending++;
				fetch(url)
					.then(function (r) { return r.json(); })
					.then(function (data) {
						var tag;
						if (api === "gitlab" && Array.isArray(data) && data.length > 0) {
							tag = data[0].name;
						} else if (prefix === "desktop-v" && Array.isArray(data)) {
							for (var j = 0; j < data.length; j++) {
								if (data[j].tag_name && data[j].tag_name.indexOf("desktop-v") === 0) {
									tag = data[j].tag_name;
									break;
								}
							}
						} else {
							tag = data.tag_name;
						}

						if (!tag) {
							appendStatus(el, "?", "ver-error");
							return;
						}

						var latest = tag;
						if (prefix && latest.indexOf(prefix) === 0) {
							latest = latest.substring(prefix.length);
						}

						cache[repo] = latest;
						showResult(el, current, latest);
					})
					.catch(function () {
						appendStatus(el, "?", "ver-error");
					})
					.finally(function () {
						if (--pending <= 0) saveCache();
					});
			}

			function showResult(el, current, latest) {
				if (latest === current) {
					appendStatus(el, "up to date", "ver-ok");
				} else {
					appendStatus(el, latest + " available", "ver-update");
				}
			}

			function appendStatus(el, text, cls) {
				var span = document.createElement("span");
				span.className = cls;
				span.textContent = " [" + text + "]";
				el.appendChild(span);
			}
		})();
	</script>
</html>
